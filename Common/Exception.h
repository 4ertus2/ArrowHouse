#pragma once

#include <cerrno>
#include <exception>
#include <memory>
#include <vector>

#include <common/defines.h>
#include <common/errnoToString.h>
#include <common/scope_guard.h>
#include <Common/StackTrace.h>

#include <fmt/format.h>


namespace AH
{

class Exception : public std::exception
{
public:
    using FramePointers = std::vector<void *>;

    Exception() { capture_thread_frame_pointers = thread_frame_pointers; }

    // delegating constructor to mask sensitive information from the message
    Exception(const std::string & msg) : Exception(MessageMasked(msg))
    {
        capture_thread_frame_pointers = thread_frame_pointers;
    }

    Exception(std::string && msg) : Exception(MessageMasked(std::move(msg)))
    {
        capture_thread_frame_pointers = thread_frame_pointers;
    }

    static thread_local std::vector<StackTrace::FramePointers> thread_frame_pointers;

protected:
    // used to remove the sensitive information from exceptions if query_masking_rules is configured
    struct MessageMasked
    {
        std::string msg;
        explicit MessageMasked(const std::string & msg_);
        explicit MessageMasked(std::string && msg_);
    };

    Exception(const MessageMasked & msg_masked);
    Exception(MessageMasked && msg_masked);

public:
    /// These creators are for messages that were received by network or generated by a third-party library in runtime.
    /// Please use a constructor for all other cases.
    static Exception createRuntime(const String & message) { return Exception(message); }
    static Exception createRuntime(String & message) { return Exception(message); }
    static Exception createRuntime(String && message) { return Exception(std::move(message)); }

    struct CreateFromSTDTag
    {
    };

    Exception(CreateFromSTDTag, const std::exception & exc);

    void rethrow() const { throw *this; } // NOLINT
    const char * what() const noexcept override { return message().data(); }

    /// Add something to the existing message.
    template <typename... Args>
    void addMessage(fmt::format_string<Args...> format, Args &&... args)
    {
        addMessage(fmt::format(format, std::forward<Args>(args)...));
    }

    void addMessage(const std::string & message) { addMessage(MessageMasked(message)); }

    void addMessage(const MessageMasked & msg_masked)
    {
#if 0
        extendedMessage(msg_masked.msg);
#else
        msg_ += "; " + msg_masked.msg;
#endif
    }

    std::string getStackTraceString() const;
    /// Used for system.errors
    FramePointers getStackFramePointers() const;

    const std::string & displayText() const { return message(); } // TODO: check if it's OK
    const std::string & message() const { return msg_; }

private:
    std::string msg_;
#ifndef STD_EXCEPTION_HAS_STACK_TRACE
    StackTrace trace;
#endif

protected:
    /// Local copy of static per-thread thread_frame_pointers, should be mutable to be unpoisoned on printout
    mutable std::vector<StackTrace::FramePointers> capture_thread_frame_pointers;
};


std::string getExceptionStackTraceString(const std::exception & e);
std::string getExceptionStackTraceString(std::exception_ptr e);


/// Contains an additional member `saved_errno`
class ErrnoException : public Exception
{
public:
    ErrnoException(std::string && msg, int with_errno, std::optional<std::string> path_ = {})
        : Exception(msg), saved_errno(with_errno), path(path_)
    {
        capture_thread_frame_pointers = thread_frame_pointers;
        addMessage(", {}", errnoToString(saved_errno));
    }

    /// Message must be a compile-time constant
    template <typename T>
    requires std::is_convertible_v<T, String>
    ErrnoException(T && message) : Exception(message), saved_errno(errno)
    {
        capture_thread_frame_pointers = thread_frame_pointers;
        addMessage(", {}", errnoToString(saved_errno));
    }

    int getErrno() const { return saved_errno; }
    std::optional<std::string> getPath() const { return path; }

private:
    int saved_errno;
    std::optional<std::string> path{};
};

using Exceptions = std::vector<std::exception_ptr>;

void tryLogCurrentException(const char * log_name, const std::string & start_of_message = "");


/** Prints current exception in canonical format.
  * with_stacktrace - prints stack trace for DB::Exception.
  * check_embedded_stacktrace - if DB::Exception has embedded stacktrace then
  *  only this stack trace will be printed.
  * with_extra_info - add information about the filesystem in case of "No space left on device" and similar.
  */
std::string getCurrentExceptionMessage(bool with_stacktrace, bool check_embedded_stacktrace = false, bool with_extra_info = true);


/// Returns string containing extra diagnostic info for specific exceptions (like "no space left on device" and "memory limit exceeded")
std::string getExtraExceptionInfo(const std::exception & e);

/// An execution status of any piece of code, contains return code and optional error
struct ExecutionStatus
{
    std::string message;

    ExecutionStatus() = default;

    explicit ExecutionStatus(const std::string & exception_message) : message(exception_message) { }

    static ExecutionStatus fromCurrentException(const std::string & start_of_message = "", bool with_stacktrace = false);

    static ExecutionStatus fromText(const std::string & data);

    std::string serializeText() const;

    void deserializeText(const std::string & data);

    bool tryDeserializeText(const std::string & data);
};

void tryLogException(std::exception_ptr e, const char * log_name, const std::string & start_of_message = "");

std::string getExceptionMessage(const Exception & e, bool with_stacktrace, bool check_embedded_stacktrace = false);
std::string getExceptionMessage(std::exception_ptr e, bool with_stacktrace);


template <typename T>
requires std::is_pointer_v<T>
T exception_cast(std::exception_ptr e)
{
    try
    {
        std::rethrow_exception(e);
    }
    catch (std::remove_pointer_t<T> & concrete)
    {
        return &concrete;
    }
    catch (...)
    {
        return nullptr;
    }
}

}
